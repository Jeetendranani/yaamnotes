"""
Technical Questions

There are logical ways to approach them:

- How to prepare
Need to try to solving problems, Memorizing solutions won't help you much. For the problem, do the following:
1. Try to solve the problem on your own. hints are provided at the backs of this book. after solve problem make sure
think about the space and time efficiency.
2. Write the code on paper.
3. test your code - on paper.
4. Type your paper code as-is into a computer. You will probably make a bunch of mistakes, start a list of the errors
you make so that you can keep these in mind during the actual interview.

- What you need to know.
    Data structures
        linked lists
        Trees, tries, and graphs todo
        heaps todo
        vectors / arraylists todo
        hash tables todo
    Algorithms
        Breadth-first search
        depth-first search
        binary search
        merge sort
        quick sort
    concepts
        bit manipulation todo
        memory (stack and help)
        recursion
        dynamic programming
        big o time & space

    powers of 2 tables

        power of 2              Exact value (x)                 approx. Value               x bytes into mb, gb, etc
             7                        128
             8                        256
             10                       1024                       1 thousand                             1k
             16                      65,535                                                            64k
             20                     1,048,576                     1 million                             1m
             30                   1,073,741,824                   1 billion                             iG
             32                   4,294,967,296                                                         4G
             40                1,099,511,627,776                  1 trillion                            1T

- Walking Through a Problem
    A problem solving flowchart

    1. Listen:  Pay very close attention to any information in the problem description. you probably need it all for
    an optimal algorithm.

    2. example: Most examples are too small or are special cases. Debug your examples, Is there any way it's a special
    case? Is it big enough?

    3. Brute Force: Get a brute-force solution as soon as possible. Don't worry about developing an efficient algorithm
    yet. State a naive algorithm and its runtime, then optimize from there. Dont' code yet though!

    4. Optimize: Walk through your brute force with BUD optimization or try some of these ideas:
        - Look for any unused info. You usually need all teh information in a problem.
        - solve it manually on an example, then reverse engineer your though process. How did you solve it?
        - solve it "incorrectly" and then think about why hte algorithms fails, can you fix those issues?
        - make a time vs space tradeoff, hash tables are especially useful!

    5. Walk through: Now that you have an optimal solution, walk through your approach in detail. Make sure you
    understand each detail before you start coding.

    6. Implement: Your goal is to write beautiful code. Modularize your code from the beginning and refactor to clean
    up anything that isn't beautiful.

    Keep talking! your interviewer wants to hear how you approach the problem.

    7. Test: Test in this order:
        1. Conceptual test. Walk through your code like you would for a detailed code review.
        2. Unusual or non-standard code.
        3. Hot spots, like arithmetic and null nodes.
        4. Small test cases, it's much faster than a big test case and just as effective.
        5. Special cases and edge cases.
    And when you find bugs, fix then carefully!

    What to expect



"""